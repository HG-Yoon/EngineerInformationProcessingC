/*
배열 field의 요소가 0이 아닌,
즉 1인 경우,
배열 mines에서 해당 위치를 중심으로
3행 3열의 범위에
1을 더하는 프로그램
*/
#include <stdio.h>
int main()
{
    int field[4][4] = {{0, 1, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}, {0, 1, 1, 1}};
    int mines[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
    int w = 4, h = 4;
    for (int y = 0; y < h; y++)
    {
        for (int x = 0; x < w; x++)
        {
            if (field[y][x] == 0)
                continue;
            for (int j = y - 1; j <= y + 1; j++)
            {
                for (int i = x - 1; i <= x + 1; i++)
                {
                    if (chkover(w, h, j, i) == 1)
                        mines[j][i] += 1;
                }
            }
        }
    }
}

int chkover(int w, int h, int j, int i)
{
    if (i >= 0 && i < w && j >= 0 && j < h)
        return 1;

    return 0;
}
/*

### 🟡 초기 `mines`

```
[0 0 0 0]
[0 0 0 0]
[0 0 0 0]
[0 0 0 0]
```

---

### 🟡 Step 1: field\[0]\[1] == 1

```
[1 1 1 0]
[1 1 1 0]
[0 0 0 0]
[0 0 0 0]
```

---

### 🟡 Step 2: field\[0]\[3] == 1

```
[1 1 2 1]
[1 1 2 1]
[0 0 0 0]
[0 0 0 0]
```

---

### 🟡 Step 3: field\[1]\[3] == 1

```
[1 1 3 2]
[1 1 3 2]
[0 0 1 1]
[0 0 0 0]
```

---

### 🟡 Step 4: field\[2]\[0] == 1

```
[1 1 3 2]
[2 2 3 2]
[1 1 1 1]
[1 1 0 0]
```

---

### 🟡 Step 5: field\[2]\[1] == 1

```
[1 1 3 2]
[3 3 4 2]
[2 2 2 1]
[2 2 1 0]
```

---

### 🟡 Step 6: field\[2]\[2] == 1

```
[1 1 3 2]
[3 4 5 3]
[2 3 3 2]
[2 3 2 1]
```

---

### 🟡 Step 7: field\[3]\[1] == 1

```
[1 1 3 2]
[3 4 5 3]
[3 4 4 2]
[3 4 3 1]
```

---

### 🟡 Step 8: field\[3]\[2] == 1

```
[1 1 3 2]
[3 4 5 3]
[3 5 5 3]
[3 5 4 2]
```

---

### 🟡 Step 9: field\[3]\[3] == 1

```
[1 1 3 2]
[3 4 5 3]
[3 5 6 4]
[3 5 5 3]
```

*/